@document.meta
title: SPEC-007-instruction-set
description: Technical Specification
authors: Your Name
categories: [spec, technical]
created: 2025-12-13
version: 0.1.0
@end

* Spec: SPEC-007-instruction-set

** Overview
   - There are 36 total instructions divided into 16 families.
   - The falmilies are identified by the most significant 4-bits of the instruction.
     For example, A602 belongs to A family which sets Adderess register(i) to lowest 12-bit of the instruction. 
     i.e chip.i = 0x602 for this example.
   - These families are defined from 0 to F(15).

** All Instructions
*** Decoding the Instruction
    - f or family - A 4-bit value, the higest 4 bits of the instruction
    - nnn or addr - A 12-bit value, Lowest 12 bits of the instruction
    - n or nibble - A 4-bit value, Lowest 4 bits of the instruction
    - x - A 4-bit value, the lower 4 bits of the higher byte of Instruction
    - y - A 4-bit value, the higher 4 bits of the lower byte of Instruction

    In Rust:
      let f = code >> 12; // Family identifier

      let nnn = code & 0x0FFF; // address
      let nn = code & 0x00FF;
      let n = code & 0x000F; // nibble

      let x = code & 0x0F00;
      let y = code & 0x00F0;

*** Identify and execute the instruction
    To identify the instruction we use nested match statements
    We first match for the family, in the execution statement of the family, match for what the instruction needs,
    execute the proper statements.

**** Rust
      match f {
        0x0 => {
          match nn { ... }
        },
        0x1 =? { ... },
        // and so on till 0xF
      }

*** 0 family

    \+-------------\+----------\+------------------------\+
    \| Instruction \| Assembly \|     Function           \|
    \+-------------\+----------\+------------------------\+
    \|    0nnn     \| SYS addr \| IGNORE                 \|
    \+-------------\+----------\+------------------------\+
    \|    00E0     \|   CLS    \| Clear Display          \|
    \+-------------\+----------\+------------------------\+
    \|    00EE     \|   RET    \| Return from subroutine \|
    \+-------------\+----------\+------------------------\+

    - 0nnn is to be ignored as it was specificaly ment for old chip-8 computers

    - 00E0 clears the screen by setting each value of of chip.display\[\] to false

    - 00EE sets chip.pc = chip.sp; chip.sp -= 1;

**** Rust
     match f {
       0x0 => match nn {
         0xE0 => {
           for ref mut i in chip.display {
             *i = flase;
           }
         },
         0xEE => {
           chip.pc = chip.sp;
           chip.sp -= 1;
         }
       },
       // Other families
     }

*** 1 family
    \+-------------\+----------\+------------------------\+
    \| Instruction \| Assembly \|     Function           \|
    \+-------------\+----------\+------------------------\+
    \|    1nnn     \| JP addr  \| Jump to addr nnn       \|
    \+-------------\+----------\+------------------------\+

    - 1nnn sets program counter to the adderess 0xNNN 

**** Rust
     match f {
      match 1 => { chip.pc = nnn},
      //other Instructions
      _ => {}
     }
** Architecture
   - Components involved...

    \+-------------\+----------\+------------------\+
    \| Instruction \| Assembly \|     Function     \|
    \+-------------\+----------\+------------------\+
    \|             \|          \|                  \|
    \+-------------\+----------\+------------------\+
    \|             \|          \|                  \|
    \+-------------\+----------\+------------------\+
    \|             \|          \|                  \|
    \+-------------\+----------\+------------------\+
