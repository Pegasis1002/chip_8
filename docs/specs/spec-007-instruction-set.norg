@document.meta
title: SPEC-007-instruction-set
description: Technical Specification
authors: Your Name
categories: [spec, technical]
created: 2025-12-13
version: 0.1.0
@end

* Spec: SPEC-007-instruction-set

** Overview
   - There are 36 total instructions divided into 16 families.
   - The falmilies are identified by the most significant 4-bits of the instruction.
     For example, A602 belongs to A family which sets Adderess register(i) to lowest 12-bit of the instruction. 
     i.e chip.i = 0x602 for this example.
   - These families are defined from 0 to F(15).

** All Instructions
*** Decoding the Instruction
    - f or family - A 4-bit value, the higest 4 bits of the instruction
    - nnn or addr - A 12-bit value, Lowest 12 bits of the instruction
    - n or nibble - A 4-bit value, Lowest 4 bits of the instruction
    - x - A 4-bit value, the lower 4 bits of the higher byte of Instruction
    - y - A 4-bit value, the higher 4 bits of the lower byte of Instruction

    In Rust:
      let f = code >> 12; // Family identifier

      let nnn = code & 0x0FFF; // address
      let nn = code & 0x00FF;
      let n = code & 0x000F; // nibble

      let x = code & 0x0F00;
      let y = code & 0x00F0;

*** Identify and execute the instruction
    To identify the instruction we use nested match statements
    We first match for the family, in the execution statement of the family, match for what the instruction needs,
    execute the proper statements.

**** Rust
      match f {
        0x0 => {
          match nn { ... }
        },
        0x1 =? { ... },
        // and so on till 0xF
      }

*** 0 family

    \+-------------\+----------\+------------------------\+
    \| Instruction \| Assembly \|     Function           \|
    \+-------------\+----------\+------------------------\+
    \|    0nnn     \| SYS addr \| IGNORE                 \|
    \+-------------\+----------\+------------------------\+
    \|    00E0     \|   CLS    \| Clear Display          \|
    \+-------------\+----------\+------------------------\+
    \|    00EE     \|   RET    \| Return from subroutine \|
    \+-------------\+----------\+------------------------\+

    - 0nnn is to be ignored as it was specificaly ment for old chip-8 computers

    - 00E0 clears the screen by setting each value of of chip.display\[\] to false

    - 00EE sets chip.pc = chip.sp; chip.sp -= 1;

**** Rust
     match f {
       0x0 => match nn {
         0xE0 => {
           for ref mut i in chip.display {
             *i = flase;
           }
         },
         0xEE => {
           chip.pc = chip.sp;
           chip.sp -= 1;
         }
       },
       // Other families
     }

*** 1 family

    \+-------------\+----------\+------------------------\+
    \| Instruction \| Assembly \|     Function           \|
    \+-------------\+----------\+------------------------\+
    \|    1nnn     \| JP addr  \| Jump to addr nnn       \|
    \+-------------\+----------\+------------------------\+

    - 1nnn sets program counter to the adderess 0xNNN 

**** Rust
     match f {
      match 1 => { chip.pc = nnn},
      //other Instructions
      _ => {}
     }

*** 2 family

    \+-------------\+-----------\+-----------------------------------\+
    \| Instruction \| Assembly  \|              Function             \|
    \+-------------\+-----------\+-----------------------------------\+
    \|    2nnn     \| Call addr \| call subroutine at addr nnn       \|
    \+-------------\+-----------\+-----------------------------------\+

    - 2nnn increments the stack pointer by 1, then push program counter into the stack and set pc to nnn.
**** Rust
     {
      chip.sp += 1;
      chip.stack\[chip.sp\] = chip.pc;
      chip.pc = nnn;
     }

*** 3 family

    \+-------------\+-------------\+-----------------------------------\+
    \| Instruction \|   Assembly  \|            Function               \|
    \+-------------\+-------------\+-----------------------------------\+
    \|    3xnn     \| SE Vx, byte \| Skip next instruction if Vx = nn  \|
    \+-------------\+-------------\+-----------------------------------\+

    - 3xnn compare the register Vx with the value of nn, if equal increament the program counter by 2.

**** Rust
     {
        if chip.v[x] == nn { chip.pc += 2 }
     }

*** 4 family

    \+-------------\+--------------\+------------------------------------\+
    \| Instruction \|   Assembly   \|            Function                \|
    \+-------------\+--------------\+------------------------------------\+
    \|    4xnn     \| SNE Vx, byte \| Skip next instruction if Vx != nn  \|
    \+-------------\+--------------\+------------------------------------\+

    - 3xnn compare the register Vx with the value of nn, if not equal increament the program counter by 2.

**** Rust
     {
        if chip.v[x] != nn { chip.pc += 2 }
     }

*** 5 family

    \+-------------\+--------------\+------------------------------------\+
    \| Instruction \|   Assembly   \|            Function                \|
    \+-------------\+--------------\+------------------------------------\+
    \|    4xy0     \| SE Vx, Vy    \| Skip next instruction if Vx == Vy  \|
    \+-------------\+--------------\+------------------------------------\+

    - 3xnn compare the register Vx with the value of Vy, if equal increament the program counter by 2.

**** Rust
     {
        if chip.v[x] != chip.v[y] { chip.pc += 2 }
     }

*** 6 family
    \+-------------\+--------------\+------------------------------------\+
    \| instruction \|   assembly   \|            function                \|
    \+-------------\+--------------\+------------------------------------\+
    \|    6xnn     \| LD Vx, byte  \| Put value of nn into Vx            \|
    \+-------------\+--------------\+------------------------------------\+

    - 6xnn sets the value of register Vx to nn.

**** Rust
     {
      chip.v[x] = nn;
     }

*** 7 family

    \+-------------\+--------------\+------------------------------------\+
    \| instruction \|   assembly   \|            function                \|
    \+-------------\+--------------\+------------------------------------\+
    \|    7xnn     \| ADD Vx, byte \| increment value of Vx by nn        \|
    \+-------------\+--------------\+------------------------------------\+

    - 7xnn add the values of Vx and nn and puts the result into Vx.

**** Rust
     {
     chip.v[x] += nn;
     }

*** 8 family
    \+-------------\+--------------\+---------------------------------------------\+
    \| instruction \|   assembly   \|            function                         \|
    \+-------------\+--------------\+---------------------------------------------\+
    \|    8xy0     \| LD Vx, Vy    \| Put value of Vy into Vx                     \|
    \+-------------\+--------------\+---------------------------------------------\+
    \|    8xy1     \| OR Vx, Vy    \| perform bitwise-OR on Vx and Vy, store in Vx\|
    \+-------------\+--------------\+---------------------------------------------\+
    \|    8xy2     \| AND Vx, Vy   \| Perform And on Vx and Vy, store in Vx       \|
    \+-------------\+--------------\+---------------------------------------------\+
    \|    8xy3     \| XOR Vx, Vy   \| Perform XOR on Vx and Vy, store in Vx       \|
    \+-------------\+--------------\+---------------------------------------------\+
    \|    8xy4     \| ADD Vx, Vy   \| Increment Vx by Vy, set VF = carry          \|
    \+-------------\+--------------\+---------------------------------------------\+
    \|    8xy5     \| SUB Vx, Vy   \| Decrement Vx by Vy, set VF = NOT borrow     \|
    \+-------------\+--------------\+---------------------------------------------\+
    \|    8xy6     \| SHR Vx \{, Vy\}\| Set Vx = Vx SHR 1                           \|
    \+-------------\+--------------\+---------------------------------------------\+
    \|    8xy7     \| SUBN Vx, Vy  \| Set Vx = Vy - Vx, set Vf = NOT bottow       \|
    \+-------------\+--------------\+---------------------------------------------\+
    \|    8xyE     \| SHL Vx \{, Vy\}\| Set Vx = Vx SHL 1                           \|
    \+-------------\+--------------\+---------------------------------------------\+

    - 8xy0 sets the value of register Vx to  value in register Vy.
    - LD Vx, Vy means to load the value in second variable into the first.

    - 8xy1 Performs bitwise OR on Vx and Vy, and stores the result in Vx.
    - 8xy2 Performs bitwise AND on Vx and Vy, and stores the result in Vx.
    - 8xy3 Performs bitwise XOR on Vx and Vy, and stores the result in Vx.
    - 8xy4 Increments The value of Vx by Vy, stores in Vx, sets a cary flag(VF).
    - 8xy5 Decrements The value of Vx by Vy, stores in Vx, sets a NOT borrow flag(VF).
    - 8xy6 Shift Vx right by 1 bit, store in Vx. The \{\} in \{, Vy\} sets Vy as Optional arg.
    - 8xy7 Decrements The value of Vy by Vx, store in Vx, Set a NOT borrow flag(VF)
    - 8xyE Shift Vx left by 1 bit, store in Vx. The \{\} in \{, Vy\} sets Vy as Optional arg.

**** Rust
     {
     chip.v[x] = chip.\[y\]; // LD Vx, Vy
     chip.v\[x] = ( chip.v\[x\] | chip.v\[y\] ) ; // OR Vx, Vy
     chip.v\[x] = ( chip.v\[x\] & chip.v\[y\] ); // AND Vx, Vy
     chip.v\[x] = ( chip.v\[x\] ^ chip.v\[y\] ); // XOR Vx, Vy
     chip.v\[x] += chip.v\[y\]; // ADD Vx, Vy
     chip.v\[x] = chip.v\[x\] - chip.v\[y\]; // SUB Vx, Vy
     chip.v\[x] >>= 1; // SHR Vx \{, Vy\}
     chip.v\[x] = chip.v\[y\] = chip.v\[x\]; // SUBN Vx, Vy
     chip.v\[x] <<= 1; // SHL Vx \{, Vy\}
     }

*** 9 Family
    \+-------------\+--------------\+------------------------------------\+
    \| instruction \|   assembly   \|            function                \|
    \+-------------\+--------------\+------------------------------------\+
    \|    9xy0     \| SNE Vx, Vy   \| skip next instruction if Vx != Vy  \|
    \+-------------\+--------------\+------------------------------------\+

    - 9xy0 compares the values of Vx and Vy, if equal increment the program counter by 2.
**** Rust
     {
     if chip.v\[x\] == chip.v\[y\] {
        chip.pc += 2;
     }
     }
*** A Family
    \+-------------\+--------------\+------------------------------------\+
    \| instruction \|   assembly   \|            function                \|
    \+-------------\+--------------\+------------------------------------\+
    \|    Annn     \| LD I, nnn    \| Set I to value of nnn              \|
    \+-------------\+--------------\+------------------------------------\+

    - Annn set the value of adderess register(I) to the value of nnn.
**** Rust
     {
     chip.i = nnn;
     }
*** B Family
    \+-------------\+--------------\+------------------------------------\+
    \| instruction \|   assembly   \|            function                \|
    \+-------------\+--------------\+------------------------------------\+
    \|    Bnnn     \| JP V0, addr  \| Jump to location nnn + V0          \|
    \+-------------\+--------------\+------------------------------------\+


    - The program counter is set to nnn plus the value of V0;

**** Rust
     {
     chip.pc = (chip.v\[0\] as u16) + nnn;
     }

*** C Family
    \+-------------\+--------------\+------------------------------------\+
    \| instruction \|   assembly   \|            function                \|
    \+-------------\+--------------\+------------------------------------\+
    \|    Cxnn     \| RND Vx, byte \| Set Vx to a random value           \|
    \+-------------\+--------------\+------------------------------------\+

    - Cxnn Set the value of register Vx to a random value
    - We use rand crate to generate a random u8
**** Rust
     {
     extern crate rand;
     use rand::Rng;
     chip.v\[x\] = rand::thread_rng().r#gen();
     }

*** D Family
    \+-------------\+--------------\+---------------------------------------------\+
    \| instruction \|   assembly   \|            function                         \|
    \+-------------\+--------------\+---------------------------------------------\+
    \|    Dxyn     \| DRW Vx, Vy, n\| Draw sprite at (Vx, Vy), set VF = collision \|
    \+-------------\+--------------\+---------------------------------------------\+

    - Draw a n-byte sprite starting at memory location I, at display location (Vx, Vy), set the Vf register to collision.
    - it read n-bytes from memory, starting at adderess stored in I,
      These bytes are these bytes are then displayed as sprites on screen at coords (Vx, Vy).
      Sprites are XORed onto the display array, if this causes any pixels to be erased, VF is set to 1.
      If the position of sprite is such that part of it is out the bounds, It is 

*** F Family

    \+-------------\+--------------\+---------------------------------------------\+
    \| instruction \|   assembly   \|            function                         \|
    \+-------------\+--------------\+---------------------------------------------\+
    \|    Fx07     \| LD Vx, DT    \| Set Vx = delay timer                        \|
    \+-------------\+--------------\+---------------------------------------------\+
    \|    Fx0A     \| LD Vx, K     \| wait for keypress, store it in Vx           \|
    \+-------------\+--------------\+---------------------------------------------\+
    \|    Fx15     \| LD DT, Vx    \| Set delay timer = Vx                        \|
    \+-------------\+--------------\+---------------------------------------------\+
    \|    Fx18     \| LD ST, Vx    \| Set sount timer = Vx                        \|
    \+-------------\+--------------\+---------------------------------------------\+
    \|    Fx1E     \| ADD I, Vx    \| Set I = I + Vx                              \|
    \+-------------\+--------------\+---------------------------------------------\+
    \|    Fx29     \| LD F, Vx     \| Set I = location of sprite with digit Vx    \|
    \+-------------\+--------------\+---------------------------------------------\+
    \|    Fx33     \| LD B, Vx     \| Store BCD rep of Vx at I, I+1, I+2          \|
    \+-------------\+--------------\+---------------------------------------------\+
    \|    Fx55     \| LD \[I\], Vx   \| Store V0 to Vx in memory at location I      \|
    \+-------------\+--------------\+---------------------------------------------\+
    \|    Fx65     \| LD Vx, \[I\]   \| Read V0 through Vx starting at loc I        \|
    \+-------------\+--------------\+---------------------------------------------\+


**** Rust
     { chip.v\[x\] = chip.dt; } // LD Vx, DT
     { chip.v\[x\] = }// Wait for key and store in Vx yet to be implemented
     { chip.dt = chip.v\[x\]; } // LD DT, Vx
     { chip.st = chip.v\[x\]; } // LD ST, Vx
     { chip.i += chip.v\[x\]; } // ADD I, Vx

     { for i in 0..0xF {
        chip.ram\[ chip.i + i\] = chip.v\[i\];
     }} // LD \[I\], Vx

     { chip.i = (0x50 + (x*5)) as u16; }

     {
                    let val = chip.v[x];
                    let i = chip.i as usize;

                    chip.ram[i] = val / 100;
                    chip.ram[i+1] = (val / 10) % 10;
                    chip.ram[i+2] = val%10;
     }
     {
     for i in 0..0xF {
     chip.v[i as usize] = chip.ram\[(chip.i + i) as usize]
     }
     }


** Architecture
   - Components involved...

    \+-------------\+----------\+------------------\+
    \| Instruction \| Assembly \|     Function     \|
    \+-------------\+----------\+------------------\+
    \|             \|          \|                  \|
    \+-------------\+----------\+------------------\+
    \|             \|          \|                  \|
    \+-------------\+----------\+------------------\+
    \|             \|          \|                  \|
    \+-------------\+----------\+------------------\+
